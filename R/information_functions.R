# Information extractor function ----

#' Gets data from the standard reference tables
#'
#' @param ref_table the reference table
#' @param input the input
#' @param output the output
#' @param compartment the compartment
#' @param na_action character, how to handle missing values, one of:
#'   `fail` (no missing values allowed), `input_ok` (allows missing values in input, but all 
#'    non-missing values must be recognised, and must have output),
#'    `output_ok`` requires all input values to be present, but allows missing values in 
#'    output (for e.g. dryweight by species), or `ok` (allows missing values everywhere)
#' @param info_type the information type, by default picked up from the function call
#' @param sep character, the separator, defaulting to '.'
#' @export
ctsm_get_info <- function(
  ref_table, 
  input, 
  output, 
  compartment = NULL, 
  na_action = c("fail", "input_ok", "output_ok", "ok"),
  info_type = NULL,
  sep = ".") {
  
  # information_functions.R
  
  # na_action: 
  #   fail doesn't allow any missing values
  #   input.ok allows missing values in input, but all non-missing values must be 
  #     recognised, and must have output
  #   output.ok requires all input values to be present, but allows missing values in 
  #     output (for e.g. dryweight by species)
  #   ok allows missing values everywhere
  
  na_action <- match.arg(na_action)

  # if not supplied, pick up info_type from function call - designed for use
  # internally; add trailing space for printing
  
  if (is.null(info_type)) {
    wk <- substitute(ref_table)
    wk <- as.character(wk)
    if (length(wk) == 3L && identical(wk[1:2], c("$", "info"))) {
      info_type <- paste0(wk[3], " ")
    } else {
      info_type <- ""
    }   
  } else {
    info_type <- paste0(info_type, " ")
  }

  
  # ensure input is character
    
  input <- as.character(input)
  
  
  # check whether input is a combination of values - sometimes used when e.g. 
  # there are two methods used in the extraction of a chemical 
  
  split_input <- any(grepl("~", na.omit(input)))
  if (split_input) {
    input2 <- strsplit(input, "~", fixed = TRUE)
  }
  
  
  # check for failure due to missing values in data or in reference table 
  
  wk <- if(split_input) unlist(input2) else input

  if (na_action %in% c("fail", "output_ok") && any(is.na(wk))) {
    stop(
      "Missing input values to ctsm_get_info with na.action set to ", 
      na_action
    )
  } 
  
  if (na_action != "ok") {
    ctsm_check_reference_table(na.omit(wk), ref_table, info_type)
  }
  

  # construct output variables and check that all information is present 
  
  if (!is.null(compartment)) {
    output <- paste(compartment, output, sep = sep)
  }
  
  if (!(output %in% names(ref_table))) { 
    stop('Incorrect specification of output variable in function ctsm_get_info')
  }
  
  
  # check that if the input has multiple values (i.e. has had to be split) each 
  # element gives the same output - then simplify input to just one of the 
  # relevant values
  
  if (split_input) {
    ok <- sapply(input2, function(i) {
      wk <- ref_table[i, output]
      length(unique(wk)) == 1L
    })
    if (any(!ok)) {
      stop(
        '\nIncompatible data found in the ', info_type, 'reference table:\n', 
        paste(input[!ok], collapse = ", "), 
        call. = FALSE
      )
    }
    input <- sapply(input2, "[", 1)
  }
  
  out <- ref_table[input, output]
  
  ok <- switch(
    na_action,
    fail = !is.na(out),
    input_ok = is.na(input) | (!is.na(input) & !is.na(out)),
    TRUE
  )
  
  if (any(!ok)) { 
    stop (
      '\nMissing output for the following input values in the', info_type, 
      'reference table:\n', 
      paste(unique(input[!ok]), collapse = ", "), 
      call. = FALSE
    )
  }

  out
}  


#' Validates data against the standard reference tables
#' 
#' This function checks inputs compatible with `ctsm_get_info` against
#' reference tables, and operates in two different ways. If `warn` is
#' `FALSE`, the default, on missing values it stops with an error, 
#' much as `ctsm_get_info` does when `na_action` is not `ok`. 
#' 
#' However if `warn` is `TRUE`, it warns instead of stopping, and
#' removes any rows that fail to match from the data, and returns a 
#' possibly modified data frame with fewer rows. 
#'
#' @param ref_table A reference table
#' @param input The input data frame -- complete, not simply a column
#' @param selector A string, the name of the column in the input we are validating against `ref_table`
#' @param info_type Behaves as in `ctsm_get_info`
#' @param warn A boolean, if `FALSE` (the default) stops with an error on missing reference data,
#'   otherwise (if `TRUE`) purges and returns mismatching records
#' @return A possibly modified data frame, identical to `input` but omitting rows where they don't match
#' @export
ctsm_validate_reference <- function(
  ref_table, 
  input, 
  selector,
  info_type = NULL,
  warn = FALSE) {
  
  if (is.null(info_type)) {
    wk <- substitute(ref_table)
    wk <- as.character(wk)
    if (length(wk) == 3L && identical(wk[1:2], c("$", "info"))) {
      info_type <- paste0(wk[3], " ")
    } else {
      info_type <- ""
    }   
  } else {
    info_type <- paste0(info_type, " ")
  }

  # ensure input is character
  input_selected <- input[[selector]]
  
  # check whether input is a combination of values - sometimes used when e.g. 
  # there are two methods used in the extraction of a chemical 
  split_input <- any(grepl("~", na.omit(input_selected)))
  if (split_input) {
    input2 <- strsplit(input_selected, "~", fixed = TRUE)
  }

  wk <- if(split_input) unlist(input2) else input_selected
  check <- na.omit(wk)
  check <- unique(check)
  
  ## The actual checks
  ok <- check %in% row.names(ref_table)

  ## Now, if we should, we can act to clean up the data
  if (!all(ok)) {
    id <- check[!ok]
    id <- sort(id)
    
    # We should either (a) stop with an error, or (b) warn and then
    # remove these entries from the data.
    handler <- if (warn) warning else stop
    handler(
      '\nThe following values are not in the ', info_type, 'reference table.\n',
      "Please add them to the reference table or edit your data to continue.\n",
      paste(id, collapse = ", "), 
      call. = FALSE
    )

    select <- ! input[[selector]] %in% id
    input <- input[select,]
  }
  
  return(input)
}


#' Checks the reference table
#' 
#' @param x what to check in the reference table
#' @param ref_table the reference table to check
#' @param info_type the name of the information type, for messaging
#' @param warn boolean, if true, warns and returns missing ids; if false,
#'   stops with an error
#' @return a vector of missing identifiers
ctsm_check_reference_table <- function(x, ref_table, info_type = "", warn = FALSE) {

  # information_functions.R
  # checks whether x is in the reference table
  
  id <- unique(x)
  
  ok <- id %in% row.names(ref_table)
  
  if (!all(ok)) {
    id <- id[!ok]
    id <- sort(id)
    handler <- if (warn) warning else stop
    handler(
      '\nThe following values are not in the ', info_type, 'reference table.\n',
      "Please add them to the reference table or edit your data to continue.\n",
      paste(id, collapse = ", "), 
      call. = FALSE
    )

    # if we pass stop (i.e., warn == TRUE), return a vector of missing identifiers
    return(id)
  }
  
  # otherwise, all is good, return an empty vector
  return(vector())
}


# Species information ----

#' @export
ctsm_read_species <- function(file) {

  var_id <- c(
    "reference_species" = "character",
    "submitted_species" = "character",
    "common_name" = "character",
    "species_group" = "character", 
    "species_subgroup" = "character", 
    "assess" = "logical"
  )
  
  required <- names(var_id)
  

  # check required variables are present in data
  
  report_file_digest(file)
  data <- safe_read_file(
    file, 
    strip.white = TRUE, 
    nrows = 1
  )
  
  ok <- required %in% names(data)
  
  if (!all(ok)) {
    id <- required[!ok]
    id <- sort(id)
    stop(
      "\nThe following variables are missing from ", file, ".\n", 
      "Please update the file to continue, noting that variable names are case ", 
      "sensitive.\n",
      "Variables: ", paste(id, collapse = ", "),
      call. = FALSE
    )
  }
  
  
  # add drywt and lipidwt conversion factors to var_id

  cf_id <- grep("_drywt|_lipidwt", names(data), value = TRUE)
  is_cf <- length(cf_id > 0)
  
  if (is_cf) {
    cf_class <- rep("numeric", length(cf_id))
    names(cf_class) <- cf_id
    var_id <- c(var_id, cf_class)
    ok <- c(required, cf_id) %in% names(data)
  }
      
  # note: don't report_file_digest() here, as we already did that once above
  data <- safe_read_file(
    file, 
    na.strings = c("", "NULL"),
    strip.white = TRUE,
    colClasses = var_id[ok]
  )
  
  
  # placeholder to create missing (non-required) variables 


  # check no missing values in required variables
  
  ok <- apply(data[required], 2, function(x) !any(is.na(x)))
  
  if (!all(ok)) {
    id <- required[!ok]
    id <- sort(id)
    stop(
      "\nThe following variables have missing values in ", file, ".\n", 
      "Please update the file to continue.\n",
      "Variables: ", paste(id, collapse = ", "),
      call. = FALSE
    )
  }
  
  
  # check no duplicate values in submitted_species

  ok <- !duplicated(data$submitted_species)
  
  if (!all(ok)) {
    id <- data$submitted_species[!ok]
    stop(
      "\nDuplicate 'submitted_species' not allowed in ", file, ".\n",
      "Please update the file to continue.\n",
      "Duplicated: ", paste(id, collapse = ", "),
      call. = FALSE
    )
  }
  
  
  # check recognised_species is a subset of submitted_species
  
  ok <- data$reference_species %in% data$submitted_species
  
  if (!all(ok)) {
    id <- data$recognised_species[!ok]
    stop(
      "\nSome 'reference_species' are not in 'submitted_species' in ", file, ".\n",
      "Please update the file to continue.\n",
      "Missing reference_species: ", paste(id, collapse = ", "),
      call. = FALSE
    )
  }
  
  
  # check species_group values are recognised
  
  group_id <- c(
    "Bird", "Bivalve", "Crustacean", "Echinoderm", "Fish", "Gastropod", 
    "Macrophyte", "Mammal", "Other"
  )
  
  ok <- data$species_group %in% group_id

  if (!all(ok)) {
    id <- data$species_group[!ok]
    id <- sort(id)
    id <- unique(id)
    stop(
      "\nUnrecongised 'species_group' values in ", file, ".\n",
      "Please update the file to continue or contact the HARSAT development ",
      "team to update\nthe list of recognised values:\n", 
      paste(group_id, collapse = ", "), "\n",
      "Unrecognised values: ", paste(id, collapse = ", "), 
      call. = FALSE
    )
  }
  

  # check no forward or backward slashes
  # will have to come back to backward slashes as these are hard to code for
  
  bad <- apply(data, 2, function(x) any(grepl("/", x, fixed = TRUE)))

  if (any(bad)) {
    id <- names(data)[bad]
    id <- sort(id)
    stop(
      "\nVariables in ", file, " have forward slashes which are not allowed.\n", 
      "Please update the file to continue.\n",
      "Variables: ", paste(id, collapse = ", "), 
      call. = FALSE
    )
  }
  
  # check conversion factors are between 0 and 100  
  
  if (is_cf) {
    values_range_check_species(data, 0, 100)
  }  
  
  
  # tidy up
  
  data <- tibble::column_to_rownames(data, "submitted_species")
  
  data
}


# function to check if species conversion factors are within pre-defined range 

values_range_check_species <- function(species_data, min_value, max_value) {

  # select conversion factor columns
  conversion_factors <- dplyr::select(
    species_data, 
    dplyr::ends_with("_drywt") | dplyr::ends_with("_lipidwt")
  )
  
  # check the condition if conversion factors are in pre-defined range
  condition <- (conversion_factors >= min_value) & (conversion_factors <= max_value)
  
  # convert NA to TRUE to only have boolean values
  condition[is.na(condition)] <- TRUE
  
  # check if all values are TRUE
  check <- all(condition == TRUE)
  
  if(!check) {
    message(
      "Warning: not all conversion factors in species reference table are within ",
      "range [min_value, max_value] !!!"
    )
  }
  
  invisible()
}



# turn drywt or lipidwt data into a more usable dataframe

get_species_cfs <- function(data, wt = c("drywt", "lipidwt")) {
  
  # silence non-standard evaluation warnings
  .data <- NULL

  # location: information_functions.R
  # purpose: gets typical species drywt / lipidwt conversion factors and converts 
  #  to a more usable form

  wt <- match.arg(wt)
  wt_adj <- paste0("_", wt)

  data <- tibble::rownames_to_column(data, "species")
  data <- dplyr::select(data, "species", dplyr::ends_with(wt_adj)) 

  
  # deal with null case where there are no conversion factors 
  
  if (ncol(data) == 1) {
    data$matrix <- NA_character_
    data[[wt]] <- NA_real_
    return(data)
  }
    
  
  data <- tidyr::pivot_longer(
    data, 
    dplyr::ends_with(wt_adj), 
    names_to = "matrix", 
    values_to = wt, 
    values_drop_na = TRUE
  )
  
  data <- tidyr::separate_wider_delim(
    data, 
    matrix, 
    delim = "_", 
    names = c("matrix", NA)
  ) 
  
  data <- as.data.frame(data)
  
  data
} 
                                   
                                   


# Determinand information and functions ----

#' @export
ctsm_read_determinand <- function(
  file, 
  compartment = c("biota", "sediment", "water"), 
  simplify = TRUE) {
  
  # location: information_functions.r
  # purpose: reads determinand reference table
  # arguments:
  # - compartment only checks for variables relevant to those compartments
  # - simplify only keeps relevant variables  
  
  # argument validation

  ok <- is.character(compartment) && length(compartment) %in% 1:3 &&
    all(compartment %in% c("biota", "sediment", "water"))
  if (!ok) {
    stop(
      "\nInvalid argment 'compartment' in function ctsm_read_determinand.\n",
      "Must be a character string with at least one of 'biota', 'sediment', ",
      "'water'.\n",
      call. = FALSE
    )
  }


  # initialise key variables
  
  var_id <- c(
    determinand = "character",
    common_name = "character",
    pargroup = "character", 
    biota_group = "character",
    sediment_group = "character",
    water_group = "character",
    biota_assess = "logical",
    sediment_assess = "logical",
    water_assess = "logical",
    biota_unit = "character",
    sediment_unit = "character", 
    water_unit = "character",       
    biota_auxiliary = "character", 
    sediment_auxiliary = "character", 
    water_auxiliary = "character", 
    biota_sd_constant = "numeric",
    biota_sd_variable = "numeric",
    sediment_sd_constant = "numeric",
    sediment_sd_variable = "numeric",
    water_sd_constant = "numeric",
    water_sd_variable = "numeric",
    distribution = "character", 
    good_status = "character"
  )
  
  required <- c(
    "determinand", "common_name", "pargroup", "distribution", "good_status"
  )
  
  extra <- c("group", "assess", "unit", "auxiliary")
  extra <- paste(rep(compartment, each = 4), extra, sep = "_")
  required <- c(required, extra)
    
  optional <- c("sd_constant", "sd_variable")
  optional <- paste(rep(compartment, each = 2), optional, sep = "_")

  
  # check required variables are present in data and issue message if optional
  # variables are not
  
  report_file_digest(file)
  data <- safe_read_file(
    file,
    strip.white = TRUE, 
    nrows = 1
  )
  
  ok <- required %in% names(data)
  
  if (!all(ok)) {
    id <- required[!ok]
    id <- sort(id)
    stop(
      "\nThe following variables are missing from ", file, ".\n", 
      "Use the 'compartment' argument to limit the required variables or update\n", 
      "the reference table to continue. Note that variable names are case sensitive.\n",
      "Variables: ", paste(id, collapse = ", "),
      call. = FALSE
    )
  }
  
    
  ok <- optional %in% names(data)
  
  if (!all(ok)) {
    id <- optional[!ok]
    message(
      "The following variables are missing from ", file, ".\n", 
      "They will be created and populated with missing values: missing ", 
      "uncertainties\ncan not be imputed and corresponding measurements will be ", 
      "deleted.\n",
      "Variables: ", paste(id, collapse = ", ")
    )
  }


  ok <- names(var_id) %in% names(data)
  
  # note: don't report_file_digest() here, as we already did that once above
  data <- safe_read_file(
    file, 
    na.strings = c("", "NULL"),
    strip.white = TRUE,
    colClasses = var_id[ok]
  )
  

  
  # ensure determinand is in upper case 
  
  data$determinand <- toupper(data$determinand)
  
  
  # fill in common name if missing and create optional variables if missing
  
  data$common_name <- ifelse(
    is.na(data$common_name), 
    data$determinand, 
    data$common_name 
  )

  
  ok <- optional %in% names(data)
  
  if (!all(ok)) {
    id <- optional[!ok]
    data[id] <- rep(NA_real_, nrow(data))
  }

  
  # retain relevant variables
  
  ok <- names(var_id) %in% c(required, optional)
  id <- names(var_id)[ok]
  data <- data[id]
  
  

  # now do some more error checking
  
  # no missing values allowed in determinand, pargroup, and assess variables
  
  var_id <- c("determinand", "pargroup", paste0(compartment, "_assess")) 
  
  not_ok <- sapply(data[var_id], function(x) any(is.na(x)))
  
  if (any(not_ok)) {
    var_id <- var_id[not_ok]
    var_id <- sort(var_id)
    stop(
      "\nThe following variables have missing values which is not allowed.\n",
      "Edit the determinand reference table to continue.\n",
      "Variables: ", paste(var_id, collapse = ", "), 
      call. = FALSE
    )
  }
  

  # check all auxiliary variables are determinands in their own right
  
  lapply(compartment, function(id) {
    
    auxiliary <- data[[paste0(id, "_auxiliary")]] 
    auxiliary <- strsplit(auxiliary, "~")
    auxiliary <- unlist(auxiliary)

    auxiliary <- unique(na.omit(auxiliary))
    
    ok <- auxiliary %in% data$determinand
    if(!all(ok)) {
      stop(
        '\nNot found in determinand information file: ', 
        paste(auxiliary[!ok], collapse = ", "), 
        call. = FALSE
      )
    }
  })
  
  
  # check no auxiliary variables are going to be assessed - this will be
  # allowed in later releases

  data[paste0(compartment, "_assess")] <- lapply(compartment, function(id) {
    
    group_id <- paste0(id, "_group")
    assess_id <- paste0(id, "_assess")

    not_ok <- data[[group_id]] %in% "Auxiliary" & data[[assess_id]]
    
    if(any(not_ok)) {
      det_id <- data$determinand[not_ok]
      det_id <- sort(det_id)
      message(
        "The following auxiliary variables have assess = TRUE which is ", 
        "currently not allowed.\nThese values of assess will be set to FALSE.\n",
        "Compartment: ", id, "\n",
        "Variables: ", paste(det_id, collapse = ", ")
      )

      data[not_ok, assess_id] <- FALSE
    }
    
    data[[assess_id]]
  })

  
  # check every variable to be assessed has a corresponding group, unit, 
  # distribution and good_status
  
  lapply(compartment, function(id) {
    
    assess_id <- paste0(id, "_assess")
    var_id <- c(paste0(id, c("_group", "_unit")), "distribution", "good_status")
    
    not_ok <- data[[assess_id]] & !complete.cases(data[var_id])
    
    if(any(not_ok)) {
      det_id <- data$determinand[not_ok]
      stop(
        "\nThe following variables with assess = TRUE have missing supporting ", 
        "information\nfor `", var_id[1], "', '", var_id[2], 
        "', `distribution` or 'good_status'.\nEdit the determinand reference ",
        "table to continue.\n",
        "Compartment: ", id, "\n",
        "Variables: ", paste(det_id, collapse = ", "), 
        call. = FALSE
      )
    }
    
  })
  


  # tidy up for output
  
  data <- tibble::column_to_rownames(data, "determinand")
  
  data
}


# extractor functions

#' Get the determinands to be assessed
#'
#' Gets the determinands to be assessed from the determinand reference table.
#'
#' @param info A list with at least the following two components:
#' * `compartment` One of `"biota"`, `"sediment"` or `"water"`
#' * `determinand` A data frame holding the determinand reference table
#'
#' @details The determinands are taken from the column `biota_assess`,
#'   `sediment_assess` or `water_assess` in the determinand reference table
#'   (where the compartment is given by `info$compartment`). `TRUE` values are
#'   determinands that are to be assessed.
#'
#' @returns A character string containing the determinands to be assessed. The
#'   function will fail with an error message if there are no such determinands.
#'
#' @export
ctsm_get_determinands <- function(info) {
  
  # information_functions.R
  
  assess_id <- paste0(info$compartment, "_assess")
  ok <- info$determinand[[assess_id]]
  
  if (!any(ok)) {
    stop(
      "\nNo determinands have been been selected for assessment.\n", 
      "Update the determinand reference table or supply the determinands\n", 
      "directly via the 'determinands' argument.", 
      call. = FALSE
    )
  }
  
  row.names(info$determinand)[ok]
}  


ctsm_get_datatype <- function(determinand, info, abbr = FALSE){
  
  # information_functions.R
  # gets the ICES data type of each determinand
  # abbr = FALSE: gives contaminant, effect, disease, auxiliary
  # abrr = TRUE: gives CF, EF, DF, AUX (biota), CS, ES, AUX (sediment), 
  #   CW, EW, AUX (water)
  
  pargroup <- ctsm_get_info(info$determinand, determinand, "pargroup")
  
  datatype <- dplyr::case_when(
    startsWith(pargroup, "O-")                 ~ "contaminant",
    startsWith(pargroup, "OC-")                ~ "contaminant",
    pargroup %in% c("I-MET", "I-RNC")          ~ "contaminant",
    pargroup %in% c("B-MBA", "B-TOX", "B-END") ~ "effect",
    pargroup %in% c("B-GRS", "B-HST")          ~ "disease",
    TRUE                                       ~ "auxiliary"
  )
  
  if (abbr) {

    if (info$compartment %in% c("sediment", "water") & any(datatype %in% "disease")) {
      warning(
        "Disease data associated with sediment o water - sounds fishy to me."
      )
    }    
      
    datatype <- dplyr::case_match(
      datatype,
      "contaminant" ~ "C",
      "effect"      ~ "E",
      "disease"     ~ "D", 
      "auxiliary"   ~ "AUX"
    )

    suffix <- switch(info$compartment, biota = "F", sediment = "S", water = "W")
    
    datatype <- dplyr::if_else(
      datatype %in% "auxiliary", 
      datatype, 
      paste0(datatype, suffix)
    )

  }    
    
  datatype
}


#' @export
ctsm_get_auxiliary <- function(determinands, info) {
  
  # information_functions.R
  # gets required auxiliary variables for determinands
  
  # in case determinands is a factor
  determinands <- as.character(determinands)
  
  determinands <- unique(determinands)
  
  # auxiliary_id <- paste0(compartment , "_auxiliary")
  # auxiliary <- info.determinand[determinands, auxiliary_id]
  
  auxiliary <- ctsm_get_info(
    info$determinand, 
    determinands, 
    "auxiliary", 
    info$compartment, 
    na_action = "output_ok", 
    sep = "_"
  )
  
  auxiliary <- strsplit(auxiliary, "~")
  auxiliary <- unlist(auxiliary)
  
  unique(c(na.omit(auxiliary)))
}



# Toxic EQuivalents for WHO_DFP (health)

# info_TEQ <- c(
#   "CB77" = 0.0001, "CB81" = 0.0003, "CB105" = 0.00003, "CB118" = 0.00003, "CB126" = 0.1, 
#   "CB156" = 0.00003, "CB157" = 0.00003, "CB167" = 0.00003, "CB169" = 0.03, 
#   "CDD1N" = 1, "CDD4X" = 0.1, "CDD6P" = 0.01, "CDD6X" = 0.1, "CDD9X" = 0.1, "CDDO" = 0.0003,
#   "CDF2N" = 0.3, "CDF2T" = 0.1, "CDF4X" = 0.1, "CDF6P" = 0.01, "CDF6X" = 0.1, "CDF9P" = 0.01,
#   "CDF9X" = 0.1, "CDFO" = 0.00003, "CDFP2" = 0.03, "CDFX1" = 0.1, "TCDD" = 1
# )



# Assessment criteria ----

#' @export
ctsm_read_thresholds <- function(
    file, compartment = c("biota", "sediment", "water"))  {
  
  compartment = match.arg(compartment)
  
  report_file_digest(file)
  data <- safe_read_file(
    file, 
    na.strings = "",
    strip.white = TRUE
  )


  # check all species are in the reference table
  # check combinations of species, species_group and species_subgroup are 
  # consistent with those in the reference table
  # check basis present for all contaminants 
    
  if (compartment == "biota") {
    
    if (any(is.na(data$matrix))) {
      stop(
        "Missing values not allowed in 'matrix' in threshold reference table", 
        call. = FALSE
      )
    }
    
    if (any(is.na(data$species) & is.na(data$species_group) & 
            is.na(data$species_subgroup))) {
      stop(
        "at least one of 'species', 'species_group' and 'species_subgroup' must be\n", 
        "supplied in threshold reference table", 
        call. = FALSE
      )
    }
    
    wk <- strsplit(data$matrix, "~")
    n <- sapply(wk, length)
    data <- data[rep(1:nrow(data), times = n), ]
    data$matrix <- unlist(wk)
  }

  if (compartment == "water") {
    
    if (any(is.na(data$filtration))) {
      stop(
        "'filtration' must be supplied in threshold reference table", 
        call. = FALSE
      )
    }
    
    wk <- strsplit(data$filtration, "~")
    n <- sapply(wk, length)
    data <- data[rep(1:nrow(data), times = n), ]
    data$filtration <- unlist(wk)
  }
  
  rownames(data) <- NULL
  
  data
}



#' Add OSPAR_subregion to simplified sediment threshold reference table
#'
#' This is a utility function to expand a simplified OSPAR sediment threshold
#' table (which is much easier for the user to edit) into the form required by 
#' `harsat` 
#'
#' @param input_file the input reference file
#' @param output_file the expanded reference file
#' @param export a boolean flag, if `FALSE`, the data is returned rather than being written to `output_file`
#'
#' @return if `export` is `FALSE` (the default), returns the expanded data
#' @export
convert_reftable <- function(
    input_file, output_file, export = TRUE) {
  
  # silence non-standard evaluation warnings
  .data <- NULL

  report_file_digest(input_file)
  data <- safe_read_file(input_file, na.strings = "", strip.white = TRUE)
  
 
  # get current ordering of determinands
  
  det_order <- unique(data$determinand)
  
   
  # add in subregions where there are blank cells
  
  id <- c(
    "Barents Sea", "Celtic Sea", "Channel", "East of Iceland", 
    "Greenland-Scotland ridge", "Irish and Scottish West Coast",
    "Irish Sea", "Northern Bay of Biscay", "Northern North Sea",
    "Norwegian Sea", "Norwegian Trench", "Skagerrak and Kattegat", 
    "Southern North Sea", "West of Iceland", "Wider Atlantic"
  )

  id <- paste(id, collapse = "~")
  
  data <- dplyr::mutate(
    data, 
    ospar_subregion = tidyr::replace_na(.data$ospar_subregion, id)
  )
  
  
  # expand table by subregion
  
  wk <- strsplit(data$ospar_subregion, "~")
  n <- sapply(wk, length)
  data <- data[rep(1:nrow(data), times = n), ]
  data$ospar_subregion <- unlist(wk)
  
  
  # order data frame - use original ordering of determinand which 
  # is usually be determinand group
  
  data <- dplyr::mutate(
    data, 
    .determinand = factor(.data$determinand, levels = det_order)
  )  
  
  data <- dplyr::arrange(
    data, 
    dplyr::across(dplyr::all_of(c(".determinand", "normaliser", "ospar_subregion")))
  )
  
  data$.determinand <- NULL
  
  # add in basis variables
  
  stopifnot(all(data$basis %in% "D"))
  
  data$basis <- NULL
  
  TV <- setdiff(names(data), c("determinand", "normaliser", "ospar_subregion"))
  
  data <- dplyr::mutate(
    data, 
    dplyr::across(
      dplyr::all_of(TV), 
      ~ ifelse(is.na(.x), NA_character_, "D"), 
      .names = "{.col}_basis"
    )
  )
  
  data <- dplyr::relocate(data, dplyr::ends_with("basis"), .before = TV[1])
  
  row.names(data) <- NULL

  if (!export) {
    return(data)
  }
  
  readr::write_excel_csv(data, output_file, na = "")
  
  invisible()
}



# gets Assessment Criteria
# determinand is a vector of length n
# info can be either a data frame or a list of appropriate supporting variables
# if a list, then each element can be either a scalar (replicated to length n), or a vector of length n
# AC is a character vector of assessment concentration types


#' Access function map
#' 
#' @export
get_AC <- vector("list", 3L)

names(get_AC) <- c("biota", "sediment", "water")

get_AC$biota <- function(data, AC, rt, export_all = FALSE) {    

  rt_id <- c("thresholds", "determinand", "species")     
  ok <- rt_id %in% names(rt)
  
  if (!all(ok)) {
    id <- rt_id[!ok]
    id <- sort(id)
    stop(
      "\nThe following reference tables are not provided.\n", 
      "Reference tables: ", paste(id, collapse = ", "),
      call. = FALSE
    )
  }
  

  ok <- AC %in% names(rt$thresholds)
  
  if (!all(ok)) {
    id <- AC[!ok]
    id <- sort(id)
    stop(
      "\nThe following thresholds are not in the thresholds reference table.\n", 
      "Thresholds: ", paste(id, collapse = ", "),
      call. = FALSE
    )
  }


  var_id <- c("determinand", "species", "matrix")
  
  ok <- var_id %in% names(data)
  
  if (!all(ok)) {
    id <- var_id[!ok]
    id <- sort(id)
    stop(
      "\nThe following variables are not in 'data'.\n", 
      "Variables: ", paste(id, collapse = ", "),
      call. = FALSE
    )
  }
  
  
  check <- ctsm_get_datatype(data$determinand, rt)
  no_basis <- !"basis" %in% names(data)
  
  if (any(check %in% "contaminant") && no_basis) {
    stop(
      "\nVariable 'basis' is not in data and is required for contaminant data."
    )
  }

  if (no_basis) {
    data$basis <- rep(NA_character_, nrow(data))
  }

  data <- dplyr::select(
    data,
    dplyr::all_of(c(var_id, "basis")), 
    dplyr::any_of(c("method_analysis", "sex"))
  )
  
  
  # add species_group and species_subgroup to data (otherwise these variables
  # will have missing values when export_all = TRUE and there are no 
  # corresponding thresholds; this would make customised functions building on
  # get_AC more error prone)

  rt$species <- tibble::rownames_to_column(rt$species, "species")

  data <- dplyr::left_join(
    data, 
    rt$species[c("species", "species_group", "species_subgroup")],
    by = "species"
  )


  # AC_data: fill out empty species, species_group and species_subgroup fields 
  # by joining with species reference table
  
  index <- paste(
    is.na(rt$thresholds$species), 
    is.na(rt$thresholds$species_group),
    is.na(rt$thresholds$species_subgroup)
  )

  rt$thresholds <- by(
    rt$thresholds, 
    index, 
    FUN = function(x) {
      var_id = c("species", "species_group", "species_subgroup")
      ok <- sapply(x[var_id], function(y) !any(is.na(y)))
      if (all(ok)) return(x)
      by_id <- var_id[ok]
      add_id <- var_id[!ok]
      dplyr::left_join(
        dplyr::select(x, -dplyr::all_of(add_id)),
        dplyr::select(rt$species, dplyr::all_of(var_id)),
        by = by_id,
        relationship = "many-to-many"  
      )
    }
  )
  
  # need to convert to class list before binding rows
      
  rt$thresholds <- lapply(rt$thresholds, "[")
  
  rt$thresholds <- dplyr::bind_rows(rt$thresholds)
  
  
  # check no ambiguous cases
  
  check <- dplyr::select(
    rt$thresholds, 
    dplyr::any_of(c("species", "determinand", "matrix", "method_analysis", "sex"))
  )
  
  if (any(duplicated(check))) {
    stop(
      "\nThe threshold reference table is ambiguous with multiple values for\n", 
      "the same combination of species, determinand, matrix, and threshold", 
      call. = FALSE
    )
  }

  
  # split into contaminants and biological effects, because joining variable
  # depends on data type and, within effects, on determinand (group)

  data$determinand_group <- ctsm_get_info(
    rt$determinand, data$determinand, "group", compartment = "biota", sep = "_"
  )

  data$datatype <- ctsm_get_datatype(data$determinand, rt)
  
  if (!all(data$datatype %in% c("contaminant", "effect"))) {
    stop("unrecognised datatype")
  }

  data$datatype <- dplyr::case_when(
    data$datatype %in% "contaminant"          ~ "contaminant", 
    data$determinand %in% "EROD"              ~ "EROD",
    data$determinand_group %in% "Metabolites" ~ "metabolites",
    TRUE                                      ~ "effect"
  )
  
  
  # match AC to data

  data$order <- 1:nrow(data)
  
  data <- split(data, data$datatype, drop = TRUE)

  data <- lapply(
    names(data), 
    FUN = function(i) {
      by_id <- c(
        "determinand", "species", "species_group", "species_subgroup", "matrix"
      )
      extra_id <- switch(
        i, 
        metabolites = "method_analysis", 
        EROD = "sex", 
        NULL
      )
      by_id <- c(by_id, extra_id)
      wk_data <- data[[i]]
      wk_data <- dplyr::select(
        wk_data, 
        dplyr::all_of(c(by_id, "basis", "datatype", "order"))
      )
      dplyr::left_join(
        wk_data, 
        rt$thresholds, 
        by = by_id, 
        relationship = "many-to-one"
      )
    }
  )

  data <- dplyr::bind_rows(data)
  data <- dplyr::arrange(data, "order")
  data$order <- NULL
  

  # add in lipid and dry weight information for basis conversion
    
  rt$species <- tibble::column_to_rownames(rt$species, "species")
  
  lipid_info <- get_species_cfs(rt$species, "lipidwt")
  drywt_info <- get_species_cfs(rt$species, "drywt")
  
  data <- dplyr::left_join(
    data, 
    drywt_info, 
    by = c("species", "matrix"), 
    relationship = "many-to-one"
  )
  
  data <- dplyr::left_join(
    data, 
    lipid_info, 
    by = c("species", "matrix"), 
    relationship = "many-to-one"
  )
  
  
  # convert basis where necessary
    
  data[AC] <- lapply(
    AC, 
    FUN = function(i) {
      AC_basis <- paste(i, "basis", sep = "_")
      ctsm_convert_basis(
        data[[i]], 
        from = data[[AC_basis]], 
        to = data$basis, 
        drywt = data$drywt, 
        lipidwt = data$lipidwt,
        exclude = data$datatype != "contaminant"
      )
    }
  )

  row.names(data) <- NULL
    
  if (export_all) {
    data <- dplyr::rename(
      data,
      species_drywt = "drywt",
      species_lipidwt = "lipidwt"
    )
    
    data <- dplyr::relocate(
      data,
      starts_with("species_"),
      .after = "species"
    )
    
    return(data)
  }
    
  data[AC]
}                           


get_AC$sediment <- function(data, AC, rt, export_all = FALSE) {   
  
  rt_id <- "thresholds"
  ok <- rt_id %in% names(rt)
  
  if (!all(ok)) {
    id <- rt_id[!ok]
    id <- sort(id)
    stop(
      "\nThe following reference tables are not provided.\n", 
      "Reference tables: ", paste(id, collapse = ", "),
      call. = FALSE
    )
  }
  
  
  ok <- AC %in% names(rt$thresholds)
  
  if (!all(ok)) {
    id <- AC[!ok]
    id <- sort(id)
    stop(
      "\nThe following thresholds are not in the thresholds reference table.\n", 
      "Thresholds: ", paste(id, collapse = ", "),
      call. = FALSE
    )
  }
  
  
  # merge by variables that are in both the data (which includes station 
  # information) and the AC table
  
  # determinand must be present
  
  var_id <- intersect(names(data), names(rt$thresholds))
  var_id <- union("determinand", var_id)

  ok <- var_id %in% names(data)
  
  if (!all(ok)) {
    id <- var_id[!ok]
    id <- sort(id)
    stop(
      "\nThe following variables are not in 'data'.\n", 
      "Variables: ", paste(id, collapse = ", "),
      call. = FALSE
    )
  }
  
  
  data <- dplyr::left_join(
    data, 
    rt$thresholds, 
    by = var_id, 
    relationship = "many-to-one"
  )
  
  row.names(data) <- NULL
  
  if (export_all) {
    return(data)
  } 

  data[AC]
}                           



get_AC$water <- function(data, AC, rt, export_all = FALSE) {   

  rt_id <- "thresholds"  
  ok <- rt_id %in% names(rt)
  
  if (!all(ok)) {
    id <- rt_id[!ok]
    id <- sort(id)
    stop(
      "\nThe following reference tables are not provided.\n", 
      "Reference tables: ", paste(id, collapse = ", "),
      call. = FALSE
    )
  }
  
  
  ok <- AC %in% names(rt$thresholds)
  
  if (!all(ok)) {
    id <- AC[!ok]
    id <- sort(id)
    stop(
      "\nThe following thresholds are not in the thresholds reference table.\n", 
      "Thresholds: ", paste(id, collapse = ", "),
      call. = FALSE
    )
  }
  
  
  var_id <- c("determinand", "filtration")
  
  ok <- var_id %in% names(data)
  
  if (!all(ok)) {
    id <- var_id[!ok]
    id <- sort(id)
    stop(
      "\nThe following variables are not in 'data'.\n", 
      "Variables: ", paste(id, collapse = ", "),
      call. = FALSE
    )
  }
  
  
  data <- dplyr::left_join(
    data, 
    rt$thresholds, 
    by = c("determinand", "filtration"),
    relationship = "many-to-one"
  )

  row.names(data) <- NULL

  if (export_all) {
    return(data)
  } 

  data[AC]
}                           


# Most of the following functions are deprecated - but need to get an OSPAR 
# threshold rt sorted


#' Gets OSPAR threshold values for biota
#' @description 
#' Extends default extractor function get_AC$biota for the few cases which can 
#' not be handled in a straightforward manner. This mostly relates to thresholds
#' which are only applied when the typical species / lipid contend is 'high' 
#' (currently defined as >= 3%)  
#'
#' @param data the data
#' @param AC a list of assessment criteria
#' @param rt the reference tables
#' @param export_all logical, default `FALSE`, if `TRUE` returns all data, 
#'   otherwise, just the assessment criteria
#'
#' @return by default, the assessment criteria, if `export_all` is set `TRUE`
#'   returns all the data instead
#' @export
get_AC_biota_OSPAR <- function(data, AC, rt, export_all = FALSE) {
  
  # silence non-standard evaluation warnings
  .data <- .id <- .AC <- NULL

  data <- get_AC$biota(data, AC, rt, export_all = TRUE)
  
  lipid_high <- 3
  
  
  # BAC for CD, PB, PCBs, DDEPP, HCB in fish only applied when lipid content >= 3%
  
  if ("BAC" %in% names(data)) {

    det_id <- c(
      "CD", "PB", 
      "CB28", "CB52", "CB101", "CB105", "CB118", "CB138", "CB153", "CB156", "CB180",
      "DDEPP", "HCB"
    )

    data <- dplyr::mutate(
      data,
      BAC = dplyr::if_else(
        .data$determinand %in% det_id & .data$species_group %in% "Fish" &
          .data$species_lipidwt < lipid_high,
        NA_real_,
        .data$BAC
      )
    )
      
  }
  

  # QShh for HCB, HCHG, SBDE6 for liver needs to be back-transformed to a wet weight 
  # basis (using liver content) and then transformed to a lipid weight bais 
  # (using muscle content); if lipid weight is high all done; if lipid weight is
  # low, need to transform to a wet weight basis (using lipid content)
  
  if ("QShh" %in% names(data)) {
    
    det_id <- c("HCB", "HCHG", "SBDE6")
    
    data <- dplyr::mutate(
      data,
      .id = .data$determinand %in% det_id & .data$species_group %in% "Fish" &
        .data$matrix %in% "LI",
      .AC = ctsm_convert_basis(
        .data$QShh, 
        .data$basis, 
        "W",
        lipidwt = .data$species_lipidwt,
        exclude = !.id,
        print_warning = FALSE
      ),
      .AC = ctsm_convert_basis(
        .AC, 
        "W", 
        "L", 
        lipidwt = rt$species[.data$species, "MU_lipidwt"],
        exclude = !.id, 
        print_warning = FALSE,
      ),
      .AC = ctsm_convert_basis(
        .AC, 
        "L", 
        .data$basis, 
        lipidwt = .data$species_lipidwt,
        exclude = !.id, 
        print_warning = FALSE
      ),
      QShh = dplyr::if_else(.id, .AC, .data$QShh), 
      .id = NULL,
      .AC = NULL
    )

  }  
  
  
  if (export_all) {
    return(data)
  } 
  
  data[AC]
}

# get.AC.OSPAR <- function(compartment, determinand, info, AC, thresholds, determinand_rt, species_rt) {
#   
#   # check elements of info are of correct length
#   
#   stopifnot(sapply(info, length) %in% c(1, length(determinand)))
#   
#   
#   # remove duplicate determinand information - need to fix this better
#   
#   info$determinand <- NULL
#   
#   
#   # turn info into a dataframe if necessary
#   
#   data <- cbind(determinand, as.data.frame(info))
#   
#   
#   # split by determinand groupings
#   
#   group <- ctsm_get_info(
#     determinand_rt, data$determinand, "group", compartment, sep = "_"
#   )
#   
#   data <- split(data, group, drop = TRUE)
#   
#   
#   # get assessment concentrations
#   
#   out <- lapply(names(data), function(i) {
#     args <- list(data = data[[i]], AC = AC, AC_data = thresholds)
#     if (compartment == "biota") args$species_rt <- species_rt
#     
#     if (compartment == "sediment") {
#       if (i == "Metals") {
#         fn = "get.AC.sediment.Metals"
#       } else {
#         fn = "get.AC.sediment.contaminant"
#       }
#     }
#     
#     if (compartment == "water") {
#       fn = "get.AC.water.contaminant"
#     }
#     
#     if (compartment == "biota") {
#       if (i %in% c(
#         "Metals", "Chlorobiphenyls", "Organochlorines", "Organofluorines", 
#         "PBDEs", "Dioxins", "Effects", "Metabolites", "Imposex")
#       ) {
#         fn = paste("get.AC.biota", i, "OSPAR", sep = ".")
#       } else {
#         fn = "get.AC.biota.contaminant"
#       }
#     }
#     
#     do.call(fn, args)
#     
#   }) 
#   
#   unsplit(out, group, drop = TRUE)
# }


# get.AC.biota.Organochlorines.OSPAR <- function(data, AC, AC_data, species_rt, lipid_high = 3) {
#   
#   out <- get.AC.biota.contaminant(data, AC, AC_data, species_rt, export_cf = TRUE)
#   
#   stopifnot(
#     length(intersect(names(data), names(out))) == 0,
#     ! c("BAC", "EAC", "EQS", "HQS") %in% names(AC)
#   )
#   
#   out <- bind_cols(out, data)
#   
#   out <- out %>%
#     rownames_to_column() %>%
#     dplyr::mutate(
#       species_group = ctsm_get_info(species_rt, .data$species, "species_group"),
#       species = as.character(species)
#     )
#   
#   
#   # BAC in fish only apply to high lipid tissue
#   # EAC for birds fro HCB and HCH
#   
#   out <- dplyr::mutate(
#     out,
#     
#     BAC = if_else(
#       .data$species_group %in% "Fish" & (is.na(.data$lipidwt) | .data$lipidwt < lipid_high),
#       NA_real_,
#       .data$BAC
#     ),
#     
#     EAC = if_else(
#       .data$species %in% c("Sterna hirundo", "Haematopus ostralegus") &
#         .data$matrix %in% "EH" & .data$determinand %in% "HCB",
#       ctsm_convert_basis(2.0, "W", .data$basis, .data$drywt, .data$lipidwt),
#       .data$EAC
#     ),
#     
#     EAC = if_else(
#       .data$species %in% c("Sterna hirundo", "Haematopus ostralegus") &
#         .data$matrix %in% "EH" & .data$determinand %in% "HCH",
#       ctsm_convert_basis(2.0, "W", .data$basis, .data$drywt, .data$lipidwt),
#       .data$EAC
#     )
#   )
#   
#   
#   # HCHG HQS in liver converted from muscle using muscle lipid content
#   
#   id <- out$determinand %in% "HCHG" & out$species_group %in% "Fish" & out$matrix %in% "LI"
#   
#   if (any(id)) {
#     
#     out[id, ] <- dplyr::mutate(
#       out[id, ],
#       .lipid_mu = info.species[.data$species, "MU_lipidwt"],
#       .dry_mu = info.species[.data$species, "MU_drywt"],
#       HQS = ctsm_convert_basis(61, "W", "L", .dry_mu, .lipid_mu),
#       HQS = ctsm_convert_basis(.data$HQS, "L", .data$basis, .data$drywt, .data$lipidwt),
#       .lipid_mu = NULL,
#       .dry_mu = NULL
#     )
#   }
#   
#   
#   # HCB HQS in liver converted from muscle using muscle lipid content
#   
#   id <- out$determinand %in% "HCB" & out$species_group %in% "Fish" & out$matrix %in% "LI"
#   
#   if (any(id)) {
#     
#     out[id, ] <- dplyr::mutate(
#       out[id, ],
#       .lipid_mu = info.species[.data$species, "MU_lipidwt"],
#       .dry_mu = info.species[.data$species, "MU_drywt"],
#       HQS = ctsm_convert_basis(10, "W", "L", .dry_mu, .lipid_mu),
#       HQS = ctsm_convert_basis(.data$HQS, "L", .data$basis, .data$drywt, .data$lipidwt),
#       .lipid_mu = NULL,
#       .dry_mu = NULL
#     )
#   }
#   
#   
#   out <- out %>%
#     column_to_rownames() %>%
#     select(all_of(AC))
#   
#   out
# }


# get.AC.biota.Organofluorines.OSPAR <- function(data, AC, AC_data, species_rt) {
#   
#   out <- get.AC.biota.contaminant(data, AC, AC_data, species_rt, export_cf = TRUE)
#   
#   stopifnot(
#     length(intersect(names(data), names(out))) == 0,
#     ! c("BAC", "EQS", "HQS") %in% names(AC)
#   )
#   
#   out <- bind_cols(out, data)
#   
#   out <- out %>%
#     rownames_to_column() %>%
#     dplyr::mutate(species_group = ctsm_get_info(species_rt, .data$species, "species_group"))
#   
#   
#   # fish liver - multiply by 5
#   
#   out <- dplyr::mutate(
#     out,
#     .id <- .data$species_group %in% "Fish" & .data$matrix %in% "LI" &
#       .data$determinand %in% "PFOS",
#     EQS = .data$EQS * if_else(.id, 5, 1),
#     HQS = .data$HQS * if_else(.id, 5, 1),
#     .id = NULL
#   )
#   
#   out <- out %>%
#     column_to_rownames() %>%
#     select(all_of(AC))
#   
#   out
# }


# get.AC.biota.PBDEs.OSPAR <- function(data, AC, AC_data, species_rt) {
#   
#   out <- get.AC.biota.contaminant(data, AC, AC_data, species_rt, export_cf = TRUE)
#   
#   stopifnot(
#     length(intersect(names(data), names(out))) == 0,
#     ! c("BAC", "FEQG", "HQS") %in% names(AC)
#   )
#   
#   out <- bind_cols(out, data)
#   
#   out <- out %>%
#     rownames_to_column() %>%
#     dplyr::mutate(
#       species_group = ctsm_get_info(species_rt, .data$species, "species_group"),
#       species = as.character(species)
#     )
#   
#   
#   # HQS in liver converted from muscle using muscle lipid content
#   
#   id <- out$determinand %in% "SBDE6" & out$species_group %in% "Fish" & out$matrix %in% "LI"
#   
#   if (any(id)) {
#     
#     out[id, ] <- dplyr::mutate(
#       out[id, ],
#       .lipid_mu = info.species[.data$species, "MU_lipidwt"],
#       .dry_mu = info.species[.data$species, "MU_drywt"],
#       HQS = ctsm_convert_basis(0.0085, "W", "L", .dry_mu, .lipid_mu),
#       HQS = ctsm_convert_basis(.data$HQS, "L", .data$basis, .data$drywt, .data$lipidwt),
#       .lipid_mu = NULL,
#       .dry_mu = NULL
#     )
#   }
#   
#   
#   out <- out %>%
#     column_to_rownames() %>%
#     select(all_of(AC))
#   
#   out
# }


# get.AC.biota.Dioxins.OSPAR <- function(data, AC, AC_data, species_rt) {
#   
#   out <- get.AC.biota.contaminant(data, AC, AC_data, species_rt, export_cf = TRUE)
#   
#   stopifnot(
#     length(intersect(names(data), names(out))) == 0,
#     ! c("BAC", "EQS", "HQS") %in% names(AC)
#   )
#   
#   out <- bind_cols(out, data)
#   
#   out <- out %>%
#     rownames_to_column() %>%
#     dplyr::mutate(species_group = ctsm_get_info(species_rt, .data$species, "species_group"))
#   
#   
#   # add in HQS of 0.02 ww for fish liver
#   
#   out <- dplyr::mutate(
#     out,
#     HQS = if_else(
#       .data$species_group %in% "Fish" & .data$matrix %in% "LI" & .data$determinand %in% "TEQDFP",
#       ctsm_convert_basis(0.02, "W", .data$basis, .data$drywt, .data$lipidwt),
#       .data$HQS
#     )
#   )
#   
#   out <- out %>%
#     column_to_rownames() %>%
#     select(all_of(AC))
#   
#   out
# }


# get.AC.biota.Effects.OSPAR <- function(data, AC, AC_data, species_rt) {
#   
#   out <- as.data.frame(do.call("cbind", sapply(AC, function(i) rep(NA, nrow(data)), simplify = FALSE)))
#   rownames(out) <- rownames(data)
#   
#   with(data, {
#     
#     if ("EROD" %in% data$determinand) {
#       
#       stopifnot("matrix" %in% names(data))
#       
#       id <- determinand %in% "EROD" & matrix %in% "LIMIC"
#       if (any(id) & "BAC" %in% AC) {
#         out$BAC[id & species %in% "Limanda limanda"] <- 680
#         out$BAC[id & species %in% "Gadus morhua"] <- 145
#         out$BAC[id & species %in% "Pleuronectes platessa"] <- 255
#         out$BAC[id & species %in% "Lepidorhombus boscii"] <- 13
#         out$BAC[id & species %in% "Callionymus lyra"] <- 202
#       }
#       
#       if ("LIS9" %in% data$matrix) {
#         stopifnot("sex" %in% names(data))
#         
#         id <- determinand %in% "EROD" & matrix %in% "LIS9"
#         
#         if ("BAC" %in% AC) {
#           out$BAC[id & species %in% "Limanda limanda" & sex %in% "F"] <- 178
#           out$BAC[id & species %in% "Limanda limanda" & sex %in% "M"] <- 147
#           out$BAC[id & species %in% "Platichthys flesus" & sex %in% "M"] <- 24
#           out$BAC[id & species %in% "Pleuronectes platessa" & sex %in% "M"] <- 9.5
#           out$BAC[id & species %in% "Mullus barbatus" & sex %in% "M"] <- 208
#         }
#       }
#     }
#     
#     if ("SFG" %in% data$determinand) {
#       id <- ctsm_get_info(species_rt, species, "species_subgroup") %in% "Mussel" &
#         determinand %in% "SFG"
#       if ("BAC" %in% AC) out$BAC[id] <- 25
#       if ("EAC" %in% AC) out$EAC[id] <- 15
#     }
#     
#     if ("SURVT" %in% data$determinand) {
#       id <- ctsm_get_info(species_rt, species, "species_subgroup") %in% "Mussel" &
#         determinand %in% "SURVT"
#       if ("BAC" %in% AC) out$BAC[id] <- 10
#       if ("EAC" %in% AC) out$EAC[id] <- 5
#     }
#     
#     if ("NRR" %in% data$determinand) {
#       id <- determinand %in% "NRR"
#       if ("BAC" %in% AC) out$BAC[id] <- 120
#       if ("EAC" %in% AC) out$EAC[id] <- 50
#     }
#     
#     if ("LP" %in% data$determinand) {
#       id <- determinand %in% "LP"
#       if ("BAC" %in% AC) out$BAC[id] <- 20
#       if ("EAC" %in% AC) out$EAC[id] <- 10
#     }
#     
#     if ("MNC" %in% data$determinand) {
#       
#       if (any(ctsm_get_info(species_rt, species, "species_subgroup") %in% "Mussel" &
#               determinand %in% "MNC"))
#         stop("AC not coded for MNC in mussels")
#       
#       id <- determinand %in% "MNC"
#       if ("BAC" %in% AC) {
#         out$BAC[id & species %in% "Platichthys flesus"] <- 0.3
#         out$BAC[id & species %in% "Limanda limanda"] <- 0.5
#         out$BAC[id & species %in% "Zoarces viviparus"] <- 0.4
#         out$BAC[id & species %in% "Gadus morhua"] <- 0.4
#         out$BAC[id & species %in% "Mullus barbatus"] <- 0.3
#       }
#     }
#     
#     if ("%DNATAIL" %in% data$determinand) {
#       id <- determinand %in% "%DNATAIL"
#       if (any(id) & "BAC" %in% AC) {
#         out$BAC[id & species %in% "Mytilus edulis"] <- 10
#         out$BAC[id & species %in% "Gadus morhua"] <- 5
#         out$BAC[id & species %in% "Limanda limanda"] <- 5
#       }
#     }
#     
#     out
#   })
# }


# get.AC.biota.Metabolites.OSPAR <- function(data, AC, AC_data, species_rt) {
#     
#   out <- as.data.frame(do.call("cbind", sapply(AC, function(i) rep(NA, nrow(data)), simplify = FALSE)))
#   rownames(out) <- rownames(data)
#   
#   with(data, {
#     
#     stopifnot("method_analysis" %in% names(data))
#     
#     if ("BAC" %in% AC) {
#       id <- species %in% "Limanda limanda"
#       out$BAC[id & determinand %in% "PYR1OH" & method_analysis %in% "HPLC-FD"] <- 16
#       out$BAC[id & determinand %in% "PA1OH" & method_analysis %in% "HPLC-FD"] <- 3.7
#       out$BAC[id & determinand %in% "PYR1OHEQ" & method_analysis %in% "FLM-SS"] <- 0.15
#       
#       id <- species %in% "Gadus morhua"
#       out$BAC[id & determinand %in% "PYR1OH" & method_analysis %in% "HPLC-FD"] <- 21
#       out$BAC[id & determinand %in% "PA1OH" & method_analysis %in% "HPLC-FD"] <- 2.7
#       out$BAC[id & determinand %in% "PYR1OHEQ" & method_analysis %in% "FLM-SS"] <- 1.1
#       
#       id <- species %in% "Platichthys flesus"
#       out$BAC[id & determinand %in% "PYR1OH" & method_analysis %in% "HPLC-FD"] <- 16
#       out$BAC[id & determinand %in% "PA1OH" & method_analysis %in% "HPLC-FD"] <- 3.7
#       out$BAC[id & determinand %in% "PYR1OHEQ" & method_analysis %in% "FLM-SS"] <- 1.3
#       
#       id <- species %in% "Melanogrammus aeglefinus"
#       out$BAC[id & determinand %in% "PYR1OH" & method_analysis %in% "HPLC-FD"] <- 13
#       out$BAC[id & determinand %in% "PA1OH" & method_analysis %in% "HPLC-FD"] <- 0.8
#       out$BAC[id & determinand %in% "PYR1OHEQ" & method_analysis %in% "FLM-SS"] <- 1.9
#     }
#     
#     if ("EAC" %in% AC) {
#       id <- species %in% "Limanda limanda"
#       out$EAC[id & determinand %in% "PYR1OHEQ" & method_analysis %in% "FLM-SS"] <- 22
#       
#       id <- species %in% "Gadus morhua"
#       out$EAC[id & determinand %in% "PYR1OH" & method_analysis %in% "GC-MS"] <- 483
#       out$EAC[id & determinand %in% "PA1OH" & method_analysis %in% "GC-MS"] <- 528
#       out$EAC[id & determinand %in% "PYR1OHEQ" & method_analysis %in% "FLM-SS"] <- 35
#       
#       id <- species %in% "Platichthys flesus"
#       out$EAC[id & determinand %in% "PYR1OHEQ" & method_analysis %in% "FLM-SS"] <- 29
#       
#       id <- species %in% "Melanogrammus aeglefinus"
#       out$EAC[id & determinand %in% "PYR1OHEQ" & method_analysis %in% "FLM-SS"] <- 35
#     }
#     
#     out
#   })
# }


# get.AC.biota.Imposex.OSPAR <- function(data, AC, AC_data, species_rt) {
# 
#   out <- as.data.frame(do.call("cbind", sapply(AC, function(i) rep(NA, nrow(data)), simplify = FALSE)))
#   rownames(out) <- rownames(data)
#   
#   with(data, {
#     
#     if ("BAC" %in% AC)
#     {
#       out$BAC[determinand %in% "VDS" & species %in% "Nucella lapillus"] <- 0.3
#       out$BAC[determinand %in% "VDS" & species %in% "Neptunea antiqua"] <- 0.3
#     }
#     
#     if ("EAC" %in% AC)
#     {
#       out$EAC[determinand %in% "VDS" & species %in% "Nucella lapillus"] <- 2.0
#       out$EAC[determinand %in% "VDS" & species %in% "Neptunea antiqua"] <- 2.0
#       out$EAC[determinand %in% "VDS" & species %in% "Tritia nitida (reticulata)"] <- 0.3
#       out$EAC[determinand %in% "VDS" & species %in% "Buccinum undatum"] <- 0.3
#     }
#     
#     out
#   })
# }




# Unit conversion ----

#' Converts units, e.g., from mg/kg to ug/kg
#' 
#' Can accept non-standard units (e.g. for biological effects) provided that 
#' `from` and `to` for these rows are identical (in which case no attempt is made 
#' to convert.
#'
#' @param conc the value to convert
#' @param from the current units
#' @param to the required units
#' @export
convert_units <- function(conc, from, to) {

  # information_functions.R
  # error checking
    
  from = as.character(from)
  to = as.character(to)
  
  if (!(length(from) %in% c(1, length(conc)))) {
    stop("lengths of input data inconsistent: compare lengths of from and conc")
  }
  
  if (!(length(to) %in% c(1, length(conc)))) {
    stop("lengths of input data inconsistent: compare lengths of to and conc")
  }
  
  
  # set up working data frame
  
  data <- data.frame(conc, from, to)
  
  not_ok <- is.na(data$from) & !is.na(data$to)
  if (any(not_ok)) stop("cannot convert units since input unit is missing")

  not_ok <- !is.na(data$from) & is.na(data$to)
  if (any(not_ok)) stop("cannot convert units since output unit is missing")
  
  
  # identify the rows where a conversion is required

  convert <- !is.na(data$from) & (data$from != data$to)
  
  if (!any(convert)) return(data$conc)


  # setup output structure and then apply conversion to restricted rows 
  # where conversion required
  
  out <- data$conc
  
  
  # get unit type and magnitude for each unit
  
  to <- convert_units_workup(data$to[convert])
  from <- convert_units_workup(data$from[convert])
  
  
  # check that units in from and to are compatible
  
  if (!identical(to$group, from$group)) {
    stop('Cannot convert between units of different types')
  }
  
  
  # finally convert units
  
  out[convert] <- out[convert] * 10^(to$magnitude - from$magnitude)
  
  out
}

  
convert_units_workup <- function(units) {
  
  # information_functions.R
  # helper function for convert_units
  
  # valid unit measurements (for conversion) and their 'type'
  # can only convert between comparable types 
  # note the special case of percentage in the weight_weight category
    
  # could add in more units but those below cover all the ones needed to date
  
  unit_group <- list(
    "length" = c("km", "m", "cm", "mm"), 
    "weight" = c("kg", "g", "mg"), 
    "volume" = c("l", "ml"), 
    "weight_volume" = c(
      "kg/l", "g/l", "mg/l", "ug/l", "ng/l", "pg/l", 
      "g/ml", "mg/ml", "ug/ml", "ng/ml", "pg/ml"
    ), 
    "weight_weight" = c(
      "kg/kg", "g/kg", "mg/kg", "ug/kg", "ng/kg", "pg/kg", 
      "g/g", "mg/g", "ug/g", "ng/g", "pg/g", 
      "mg/mg", "ug/ug", "ng/ng", "pg/pg", 
      "%"
    ),
    "TEQ_weight_weight" = c("TEQ ug/kg", "TEQ pg/g"),
    "mol_min_weight" = c(
      "umol/min/mg protein", "nmol/min/mg protein", "pmol/min/mg protein"
    )
  )
  
  
  # the magnitude of each unit 
  
  unit_magnitude <- list(
    "-3" = c("km", "kg"),
    "0" = c(
      "m", "g", "l", "kg/l", "g/ml", 
      "kg/kg", "g/g", "mg/mg", "ug/ug", "ng/ng", "pg/pg"
    ),  
    "2" = c("%", "cm"), 
    "3" = c("mm", "mg", "ml", "g/l", "mg/ml", "g/kg", "mg/g"), 
    "6" = c("mg/l", "ug/ml", "mg/kg", "ug/g", "umol/min/mg protein"), 
    "9" = c("ug/l", "ng/ml", "ug/kg", "ng/g", "TEQ ug/kg", "nmol/min/mg protein"), 
    "12" = c("ng/l", "pg/ml", "ng/kg", "pg/g", "TEQ pg/g", "pmol/min/mg protein"), 
    "15" = c("pg/l", "pg/kg")
  )
  
  
  # ensure the two lists have identical units
  
  check1 <- sort(unname(unlist(unit_group)))
  check2 <- sort(unname(unlist(unit_magnitude)))
  stopifnot(identical(check1, check2))
  
  
  # check all units in the data have a valid type and magnitude 
  
  unit_levels <- unlist(unit_group)
  
  ok <- units %in% unit_levels
  if (any(!ok)) {
    stop('Unrecognised units: ', paste(unique(units[!ok]), collapse = ", "))
  }
  
  
  # create data frame with the group and mangitude of each unit in the data
  
  out <- data.frame(units)
  
  out$group <- out$magnitude <- factor(out$units, levels = unit_levels)
  
  levels(out$group) <- unit_group
  out$group <- as.character(out$group)
  
  levels(out$magnitude) <- unit_magnitude
  out$magnitude <- as.numeric(as.character(out$magnitude))
  
  out        
}



#' Basis and matrix information and basis conversion
#' 
#' Converts concentrations between wet, dry and lipid bases
#' 
#' @param conc the concentration
#' @param from the current basis
#' @param to the target basis
#' @param drywt assumed to be a percentage taking values in \[0, 100\]
#' @param lipidwt assumed to be a percentage taking values in \[0, 100\];
#'   assumed to be on a wet weight basis
#' @param drywt_censoring required when `drywt` is present, 
#'   character: must be '', '<', 'D', 'Q' or NA
#' @param lipidwt_censoring required when `lipidwt` is present, 
#'   character: must be '', '<', 'D', 'Q' or NA
#' @param exclude a logical identifying records that do not need to be converted,
#'   useful when the data contain biological effects measurements
#' @param print_warning a boolean, gives the number of records lost during conversion
#' @export
ctsm_convert_basis <- function(
  conc, from, to, 
  drywt = NA_real_, 
  lipidwt = NA_real_, 
  drywt_censoring = ifelse(is.na(drywt), NA_character_, ""), 
  lipidwt_censoring = ifelse(is.na(lipidwt), NA_character_, ""), 
  exclude = FALSE, 
  print_warning = TRUE) {

  # silence non-standard evaluation warnings
  .data <- NULL

  # lipidwt assumed to be on a wet weight basis - could generalise (issue raised)
  
  # set up working data frame
  
  data <- data.frame(
    conc, from, to, drywt, drywt_censoring, lipidwt, lipidwt_censoring, exclude 
  )

  
  # ensure variables are stored as characters (rather than factors)
  
  var_id <- c("from", "to", "drywt_censoring", "lipidwt_censoring")
  data <- dplyr::mutate(data, dplyr::across(dplyr::all_of(var_id), as.character))

  
  # check arguments have admissible values
  
  ctsm_check_convert_basis(data)
  

  # only need to convert records which are 
  # a) not excluded
  # b) concentration is not missing
  # c) from and to differ
  
  data$exclude <- data$exclude | 
    is.na(data$conc) |
    (!is.na(data$from) & !is.na(data$to) & data$from == data$to)
  
  if (all(data$exclude)) {
    return(data$conc)
  }


  # set up extra variables to do the conversion

  data <- dplyr::mutate(
    data, 
    from_value = dplyr::case_when(
      .data$from %in% "W" ~ 100, 
      .data$from %in% "D" ~ drywt, 
      .data$from %in% "L" ~ lipidwt,
      TRUE                ~ NA_real_
    ),
    from_censoring = dplyr::case_when(
      .data$from %in% "W" ~ "", 
      .data$from %in% "D" ~ drywt_censoring, 
      .data$from %in% "L" ~ lipidwt_censoring,
      TRUE                ~ NA_character_ 
    ),
    to_value = dplyr::case_when(
      .data$to %in% "W" ~ 100, 
      .data$to %in% "D" ~ drywt, 
      .data$to %in% "L" ~ lipidwt,
      TRUE              ~ NA_real_
    ),
    to_censoring = dplyr::case_when(
      .data$to %in% "W" ~ "", 
      .data$to %in% "D" ~ drywt_censoring, 
      .data$to %in% "L" ~ lipidwt_censoring,
      TRUE              ~ NA_character_ 
    )
  )
  
  
  # conversion not possible if missing or censored dry or lipid data or because 
  # the to_value is 0%
  
  data <- dplyr::mutate(
    data, 
    convert = !.data$exclude,
    convert_ok = .data$convert & 
      !is.na(.data$to_value) & !is.na(.data$from_value) & 
      data$from_censoring %in% "" & .data$to_censoring %in% "" &
      .data$to_value > 0
  )  
  
  if (sum(data$convert_ok) < sum(data$convert) && print_warning) {
    message(
      "   Losing ", sum(data$convert) - sum(data$convert_ok), " out of ", 
      nrow(data), " records in basis conversion due to missing, censored\n",
      "   or zero drywt or lipidwt values."
    )
  }
    
  
  # finally convert
  
  conc = dplyr::case_when(
    !data$convert    ~ data$conc,
    !data$convert_ok ~ NA_real_,
    TRUE             ~ data$conc * data$from_value / data$to_value
  )

  conc
}


ctsm_check_convert_basis <- function(data) {

  # source: information_functions.R
  # dependencies: dplyr

  # check inputs to ctsm_convert_basis are valid
  
  if (any(is.na(data$exclude))) {
    stop("Missing values not allowed in 'exclude'")
  }
  

  # only need to consider values in records which are 
  # a) not excluded
  # b) concentration is not missing
  # c) from and to differ

  data$exclude <- data$exclude | 
    is.na(data$conc) |
    (!is.na(data$from) & !is.na(data$to) & data$from == data$to)

  if (all(data$exclude)) {
    return(invisible())
  }
  
  data <- data[!data$exclude, ]
  
  
  # from and to 

  not_ok <- c(any(is.na(data$from)), any(is.na(data$to)))
  
  if (any(not_ok)) {
    txt <- c('from', 'to')[not_ok]
    txt <- paste(txt, collapse = ", and ")
    warning(
      "Missing basis values in ", txt,  
      "; associated concentrations will be set to missing.\n", 
      "The exclude argument can prevent basis conversion (and ", 
      "suppress this warning);\n",
      "this would be appropriate for biological effects or auxiliary variables.", 
      call. = FALSE, immediate. = TRUE
    )
  }
  
  if (!all(data$from %in% c("W", "D", "L", NA_character_))) {
    stop("Unexpected basis values in 'from': must be 'W', 'D', 'L' or NA")
  }  

  if (!all(data$to %in% c("W", "D", "L", NA_character_))) {
    stop("Unexpected basis values in 'to': must be 'W', 'D', 'L' or NA")
  }  
  

  # drywt and lipidwt
  
  if (!all(is.na(data$drywt) | dplyr::between(data$drywt, 0, 100))) {
    stop("Some drywt values are less than 0% or greater than 100%")
  }

  if (!all(is.na(data$lipidwt) | dplyr::between(data$lipidwt, 0, 100))) {
    stop("Some lipidwt values are less than 0% or greater than 100%")
  }
  

  # validate drywt_censoring and lipidwt_censoring

  if (any(!is.na(data$drywt) & is.na(data$drywt_censoring))) {
    warning(
      "Missing drywt_censoring values when drywt is present;\n",  
      "this might result in data getting lost during basis conversion.",
      call. = FALSE
    )
  }
    
  if (any(!is.na(data$lipidwt) & is.na(data$lipidwt_censoring))) {
    warning(
      "Missing lipidwt_censoring values when lipidwt is present;\n",  
      "this might result in data getting lost during basis conversion.",
      call. = FALSE
    )
  }
  
  if (!all(data$drywt_censoring %in% c("", "<", "D", "Q", NA_character_))) {
    stop(
      "Unexpected drywt_censoring values: must be '', '<', 'D', 'Q' or NA.\n",
      "If you have greater_than values, contact the HARSAT development team."
    )
  }  
  
  if (!all(data$lipidwt_censoring %in% c("", "<", "D", "Q", NA_character_))) {
    stop(
      "Unexpected lipidwt_censoring values: must be '', '<', 'D', 'Q' or NA.\n",
      "If you have greater_than values, contact the HARSAT development team."
    )
  }  

  invisible()
}




# four get_basis functions defined here

# default is very simplistic, but works in all cases for sediment and water
# most_common was used by AMAP in their mercury assessment and takes the most 
#   common basis reported in each station, species (biota), matrix and  
#   determinand_group combination
# biota_OSPAR is the current (2023) OSPAR biota configuration
# biota_HELCOM is the current (2023) HELCOM biota configuration

#' The default function for generating a basis
#' 
#' This default is very simplistic, but works in all cases for sediment and water
#' most_common was used by AMAP in their mercury assessment and takes the most 
#' common basis reported in each station, species (biota), matrix and  
#' determinand_group combination
#' 
#' @param data the data
#' @param info the information object
#' @export
get_basis_default <- function(data, info) {
  
  # gets default target basis - information_functions.r
  
  # biota: W
  # sediment: D
  # water: W
  
  # the exceptions are biological effects measurements where it is assumed the 
  # data are submitted on the correct basis (or where basis isn't relevant)
  
  basis_id <- switch(
    info$compartment, 
    biota = "W", 
    sediment = "D",
    water = "W"
  )
  
  new_basis <- dplyr::if_else(
    data$group %in% c("Imposex", "Metabolites", "Effects"), 
    NA_character_, 
    basis_id
  )
  
  new_basis  
}

#' @export
get_basis_most_common <- function(data, info) {

  # gets target basis defined as the most commonly reported basis 
  # information_function.r
  
  # the basis most reported within a particular station, species, matrix and 
  # determinand group (regardless of whether auxiliary variables are present to 
  # enable conversion)
  
  # get grouping identifier
  
  var_id <- c("station", "species", "matrix", "group")
  var_id <- intersect(var_id, names(data))
  
  data$.id <- do.call("paste", c(data[var_id], sep = "_"))
  
  
  # provide index to ensure output is in same order as original
  
  data$.order <- 1:nrow(data)
  
  
  # get modal basis within each group
  
  out <- by(data, data$.id, function(x) {
    
    # deal with e.g. biological effects which don't have a basis
    
    if (unique(x$group) %in% c("Metabolites", "Imposex", "Effects")) {
      x$new_basis <- rep(NA_character_, nrow(x))
      x <- x[c(".order", "new_basis")]
      return(x)
    }
    
    # check that have full basis information
    
    if (any(is.na(x$basis))) {
      stop("missing basis information for the following: ", unique(x$.id))
    }
    
    wk <- table(x$basis)
    x$new_basis = names(wk)[which.max(wk)]
    x[c(".order", "new_basis")]
  })
  
  out <- do.call(rbind, out)
  
  
  # return to the original ordering
  
  out <- out[order(out$.order), ]
  
  out$new_basis
}



#' Gets the OSPAR biota target basis
#' 
#' @param data the data
#' @param info the information object
#' @export
get_basis_biota_OSPAR <- function(data, info) {
  
  # silence non-standard evaluation warnings
  .data <- NULL

  # note hard-wiring of lipid_high which should be passed as a control variable
  
  if (info$compartment != "biota"){
    stop("Incorrect compartment specified")
  }
  
  
  # define cut-off for using lipid as a basis 
  
  lipid_high <- 3.0
  

  # combine input variables and get species family
  
  out <- data[c("species", "matrix", "determinand", "group")]
  
  out <- dplyr::mutate(
    out,
    dplyr::across(dplyr::everything(), as.character),
    species_group = ctsm_get_info(info$species, .data$species, "species_group")
  )
  

  # get typical lipid content by species and matrix 
  
  lipid_info <- get_species_cfs(info$species, "lipidwt")
  
  out <- dplyr::left_join(out, lipid_info, by = c("species", "matrix"))
  
  # default basis W
  # bivalves and gastropods - D
  # fish and crustacea:
  #   organobromines and organochlorines (except chlorinated paraffins) L
  # mammals (based on data submissions): 
  #   hair D 
  #   metals W
  #   organics L (note organofluorines submitted on L, with no associated
  #     lw, so can't convert)
  # birds: 
  #   Alle alle (BL, FE) D
  #   Rissa tridactyla (ER) D
  #   remaining data (other than EH) (BL, FE, LI, MU) W
  #   EH metals W (apart from Larus argentatus D)
  #   EH organofluorines W
  #   EH organics L (Cepphus grylle, Haematopus ostralegus, Sterna hirundo)
  #               W (Larus argentatus, Somateria mollissima)
  
  lw_group <- c("PBDEs", "Organobromines", "Chlorobiphenyls", "Dioxins", "Organochlorines")
  
  out <- dplyr::mutate(
    out,
    .lw = .data$group %in% lw_group & !(.data$determinand %in% c("MCCP", "SCCP")),
    new_basis = dplyr::case_when(
      .data$group %in% c("Imposex", "Effects", "Metabolites")            ~ NA_character_,
      .data$species_group %in% c("Bivalve", "Gastropod")               ~ "D",
      .data$species_group %in% c("Fish", "Crustacean") & 
        .lw &
        .data$lipidwt >= lipid_high                                     ~ "L",
      .data$species_group %in% c("Fish", "Crustacean")                    ~ "W",
      .data$species_group %in% "Mammal" & .data$matrix %in% "HA"         ~ "D",
      .data$species_group %in% "Mammal" & .data$group %in% "Metals"      ~ "W",
      .data$species_group %in% "Mammal"                                  ~ "L",
      .data$species %in% c("Alle alle", "Rissa tridactyla")              ~ "D",
      .data$matrix %in% "EH" & .data$group %in% "Metals" & 
        .data$species %in% "Larus argentatus"                            ~ "D",
      .data$matrix %in% "EH" & .data$group %in% "Metals"                 ~ "W",
      .data$matrix %in% "EH" & .data$group %in% "Organofluorines"        ~ "W",
      .data$matrix %in% "EH" & 
        .data$species %in% c(
          "Cepphus grylle", "Haematopus ostralegus", "Sterna hirundo"
        )                                                                ~ "L",
      .data$matrix %in% "EH" & 
        .data$species %in% c("Larus argentatus", "Somateria mollissima") ~ "W",
      .data$species_group %in% "Bird"                                    ~ "W"
    )
  )
  
  out$new_basis
}



# Matrix ----

ctsm_read_matrix <- function(file) {
  report_file_digest(file)
  safe_read_file(
    file, 
    row.names = "matrix", 
    strip.white = TRUE
  )
}


# Regions ----

ctsm_read_regions <- function(file, purpose) {

  if (purpose != "OSPAR") {
    stop(
      "\nctsm_read_region not coded for purposes other than OSPAR.\n",
      "Contact the HARSAT development team.",
      call. = FALSE
    )
  }
  
  report_file_digest(file)
  safe_read_file(
    file, 
    row.names = "OSPAR_subregion", 
    strip.white = TRUE
  )
}  



# Method of extraction and pivot values ----

ctsm_read_method_extraction <- function(file) {
  report_file_digest(file)
  safe_read_file(
    file, 
    row.names = "METCX",  
    na.strings = "",
    strip.white = TRUE
  )
}


ctsm_read_pivot_values <- function(file) {
  report_file_digest(file)
  safe_read_file(
    file, 
    na.strings = "",
    strip.white = TRUE
  )
}



# Imposex ----

ctsm_read_imposex <- function(file) {
  report_file_digest(file)
  safe_read_file(
    file, 
    na.strings = "",
    strip.white = TRUE
  )
} 

get.info.imposex <- function(
    species, determinand, info.imposex, choice = c("min_value", "max_value"), 
    na.action = c("fail", "ok")) {
  
  choice <- match.arg(choice)
  na.action <- match.arg(na.action)

  info <- info.imposex[[choice]]
  names(info) <- do.call("paste", info.imposex[c("species", "determinand")])
  
  id <- paste(species, determinand)
  ok <- id %in% names(info)
  
  if (!all(ok)) {
    message <- paste0("Species determinand combinations not recognised: ", 
                      paste(unique(id[!ok]), collapse = ", "))
    if (na.action == "fail") stop(message) else warning(message)
  }
  
  out <- rep(NA, length(id))
  out[ok] <- info[id[ok]]  
  names(out) <- NULL
  out
}



# TEF values ----

#' TEF values for selected groups of compounds
#' 
#' A list of named vectors which currently provide the TEFs for the WHO TEQ for 
#' dioxins, furans and dioxin-like (planar) polychlorinated biphenyls.
#' DFP_environmental and DFP_human_health provide the TEFs appropriate for 
#' testing against the environmental and human health standards respectively.
#' 
#' Adding further TEFs will require more development to the relevant 
#' determinand_link function 
#' 
#' @export 
info_TEF <- list(
  DFP_environmental = c(
    "CB77" = 0.0001, "CB81" = 0.0003, "CB105" = 0.00003, "CB118" = 0.00003, 
    "CB126" = 0.1, "CB156" = 0.00003, "CB157" = 0.00003, "CB167" = 0.00003, 
    "CB169" = 0.03, "CDD1N" = 1, "CDD4X" = 0.1, "CDD6P" = 0.01, "CDD6X" = 0.1, 
    "CDD9X" = 0.1, "CDDO" = 0.0003, "CDF2N" = 0.3, "CDF2T" = 0.1, "CDF4X" = 0.1, 
    "CDF6P" = 0.01, "CDF6X" = 0.1, "CDF9P" = 0.01,
    "CDF9X" = 0.1, "CDFO" = 0.00003, "CDFP2" = 0.03, "CDFX1" = 0.1, "TCDD" = 1
  ), 
  DFP_human_health = c(
    "CB77" = 0.0001, "CB81" = 0.0003, "CB105" = 0.00003, "CB118" = 0.00003, 
    "CB126" = 0.1, "CB156" = 0.00003, "CB157" = 0.00003, "CB167" = 0.00003, 
    "CB169" = 0.03, "CDD1N" = 1, "CDD4X" = 0.1, "CDD6P" = 0.01, "CDD6X" = 0.1, 
    "CDD9X" = 0.1, "CDDO" = 0.0003, "CDF2N" = 0.3, "CDF2T" = 0.1, "CDF4X" = 0.1, 
    "CDF6P" = 0.01, "CDF6X" = 0.1, "CDF9P" = 0.01,
    "CDF9X" = 0.1, "CDFO" = 0.0003, "CDFP2" = 0.03, "CDFX1" = 0.1, "TCDD" = 1
  )
)



# ICES RECO codes ----

# reads in data from csv files exported from ICES RECO
#
# generally based on read.csv, but sometimes csv export compromised e.g when commas are present in 
# chemical parameter descriptions


# get_RECO <- function(code, path = "information") {
#  
#   # check code argument and convert to upper case
#  
#   if(!is.character(code) | length(code) != 1L)
#     stop("code must be a length 1 character")
#  
#   code <- toupper(code)
#  
#  
#   # get list of available RECO files
#  
#   files <- list.files(path)
#  
#   ok <-substring(files, 1, 5) == "RECO_"
#  
#   if (!any(ok)) 
#     stop("no RECO files found")
#  
#   files <- files[ok]
#  
#  
#   # get relevant file
#  
#   file_codes <- strsplit(files, "_") 
#   file_codes <- sapply(file_codes, "[[", 2)
#  
#   ok <- file_codes %in% code
#
#   if (!any(ok)) 
#     stop("RECO file for this code not found")
#  
#   if (sum(ok) >= 2L)
#     stop("multiple REcO files found for this code")
#  
#   infile <- files[ok]
#  
#   infile <- file.path(path, infile)
#  
#
#   # read in file - need to do something different for PARAM
#  
#   if (!code %in% "PARAM") {
#     out <- readr::read_csv(
#       infile, 
#       col_types = cols(
#         tblCodeID = col_integer(),
#         Code = col_character(),
#         Description = col_character(),
#         tblCodeTypeID = col_integer(),
#         CodeType = col_character(),
#         Created = col_date(format = ""),
#         Modified = col_date(format = ""),
#         Deprecated = col_logical()
#       )
#     ) 
#    
#     out <- as.data.frame(out)
#    
#     names(out)[2] <- code
#     return(out)
#   }
#
#
#   # special case for PARAM required because there are columns in the Description column
#  
#   # read in each row as a single character string and split by commas
#  
#   data <- readr::read_delim(
#     infile, 
#     delim = "\n",
#     col_types = cols(
#       `tblCodeID,Code,Description,tblCodeTypeID,CodeType,Created,Modified,Deprecated` = col_character()
#     )
#   ) 
#  
#   data <- as.data.frame(data)
#   names(data) <- "X" 
#  
#   data <- strsplit(data$X, ",")
#  
#   out <- data.frame(
#     tblCodeID = sapply(data, function(x) {n <- length(x); x[1]}),
#     Code = sapply(data, function(x) {n <- length(x); x[2]}),
#     Description = sapply(data, function(x) {n <- length(x); paste(x[3:(n-5)], collapse = ",")}),
#     tblCodeTypeID = sapply(data, function(x) {n <- length(x); x[n-4]}),
#     CodeType = sapply(data, function(x) {n <- length(x); x[n-3]}),
#     Created = sapply(data, function(x) {n <- length(x); x[n-2]}),
#     Modified = sapply(data, function(x) {n <- length(x); x[n-1]}),
#     Deprecated = sapply(data, function(x) {n <- length(x); x[n]}),
#     stringsAsFactors = FALSE
#   )
#
#   out <- dplyr::mutate(
#     out, 
#     across(c("tblCodeID", "tblCodeTypeID"), as.integer),  
#     across(c("Created", "Modified"), as_date), 
#     across("Deprecated", as.logical)
#   )
#
#   names(out)[2] <- code
#   out
# }


# Station utility functions ----

#' Get station code from station name
#' @description 
#' Gets the station code corresponding to the station name and country from the 
#' station dictionary. 
#'
#' @param station_name a station name
#' @param country a country
#' @param stations the station dictionary
#' @export
get_station_code <- function(station_name, country, stations) {
    
  # silence non-standard evaluation warnings
  .data <- NULL

  n <- length(station_name)
  
  if (!(length(country) %in% c(1L, n))) {
    stop(
      "'country' must either be a single character or the same length as 'station_name'"
    )  
  }
  
  out <- data.frame(station_name = station_name, country = country) 

  if (any(is.na(out))) {
    stop("missing values not allowed in 'station_name' or 'country'")
  }
    
  id <- c("station_name", "country")
  out <- dplyr::mutate(out, dplyr::across(dplyr::all_of(id), as.character))
    
  id <- c("station_name", "country", "station_code")
  stations <- stations[c("station_name", "country", "station_code")]
  stations <- dplyr::mutate(stations, dplyr::across(dplyr::all_of(id), as.character)) 
  
  out <- dplyr::left_join(
    out, 
    stations, 
    by = c("station_name", "country"), 
    relationship = "many-to-many"
  )
  
  if (any(is.na(out$station_code))) {
    out_error <- dplyr::filter(out, is.na(.data$station_code))
    out_error <- paste(out_error$country, out_error$station_name)
    warning(
      "the following station_names are not recognised:\n", 
      paste(out_error, collapse = "\n"), 
      immediate. = TRUE
    )
  }
  
  if (nrow(out) != n) {
    out_error <- unique(out)
    out_error <- tidyr::unite(
      out_error, 
      "id", 
      dplyr::all_of(c("country", "station_name")),
      sep = " "
    )
    out_error <- dplyr::filter(
      out_error, 
      .data$id %in% .data$id[duplicated(.data$id)]
    )
    out_error <- paste(out_error$id, out_error$station_code)
    stop(
      "the following station_names match to multiple station_codes:\n", 
      paste(out_error, collapse = "\n")
    )
  }
    
  out$station_code
}
